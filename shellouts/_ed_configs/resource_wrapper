#!/usr/bin/env python
#
#This file is part of "jiffy".
#
#Project: jiffy: A product for building and managing infrastructure: 
#cloud provider services, and servers and their configurations.
#
#Description: A product for building and managing infrastructure. 
#This includes third party API calls for services such as virtual
#cloud servers, load balancers, databases, and other. The product 
#manages connectivity and appropriate communication among these 
#aws.
#
#Copyright (C) Gary Leong - All Rights Reserved
#Unauthorized copying of this file, via any medium is strictly prohibited
#Proprietary and confidential
#Written by Gary Leong  <gwleong@gmail.com, September 17,2015

import jinja2
import os
import json
import sys
from time import sleep

from ed_helper_publisher.loggerly import ElasticDevLogger
from ed_helper_publisher.resource_manage import ResourceCmdHelper
from ed_helper_publisher.output import convert_ed_output_to_values

class Main(ResourceCmdHelper):

    def __init__(self,**kwargs):

        ResourceCmdHelper.__init__(self)
        self.classname = 'TerraformWrapper'
        self.logger = ElasticDevLogger(self.classname,logcategory="cloudprovider")
        self.logger.debug("Instantiating %s" % self.classname)

        self.working_subdir = os.environ.get("TERRAFORM_DIR")
        if not self.working_subdir: self.working_subdir = os.environ.get("WORKING_DIR","var/tmp/terraform")

        self.postscript = os.environ.get("POSTSCRIPT","print_ed_output")
        self.terraform_template_files = os.environ.get("TERRAFORM_TEMPLATE_FILES")

        if not self.terraform_template_files:
            self.terraform_template_files = [ "variables" ]
        else:
            self.terraform_template_files = [ template_file.strip() for template_file in self.terraform_template_files.split(",") ]

        self.run_dir = os.getcwd()
        self.terraform_dir = os.path.join(self.run_dir,self.working_subdir)
        self.postscript_path = os.path.join(self.terraform_dir,self.postscript)
        self.docker_image = os.environ.get("DOCKER_EXEC_ENV","elasticdev/terraform-run-env")
        self.share_dir = os.environ.get("SHARE_DIR","/var/tmp/share")
        self.use_docker = os.environ.get("USE_DOCKER")
        self.stateful_id = os.environ.get("STATEFUL_ID")
        self.shelloutconfig = "elasticdev:::terraform::resource_wrapper:73"

    def _templify(self,**kwargs):

        clobber = kwargs.get("clobber")

        for template_file in self.terraform_template_files:

            template_filepath = os.path.join(self.terraform_dir,"{}.ja2".format(template_file))
            file_path = os.path.join(self.terraform_dir,"{}.tf".format(template_file))

            if os.path.exists(file_path) and not clobber:
                self.logger.warn("terraform variables file already exists at {} - skipping templifying of it".format(file_path))
                return

            if not os.path.exists(template_filepath):
                self.logger.error("terraform variables template does not exists at {} - skipping templifying of it".format(template_filepath))
                os.chdir(self.run_dir)
                exit(9)
                return

            self.logger.debug("creating terraform variables file {} from {}".format(file_path,template_filepath))

            templateVars = {}

            for _var in os.environ["OS_TEMPLATE_VARS"].split(","):
                var = _var.strip().upper()
                if not os.environ.get(var): continue
                # For Terraform, you need to use double quotes instead of second quotes
                templateVars[var] = os.environ[var].replace("'",'"')

            templateLoader = jinja2.FileSystemLoader(searchpath="/")
            templateEnv = jinja2.Environment(loader=templateLoader)
            template = templateEnv.get_template(template_filepath)
            outputText = template.render( templateVars )
            writefile = open(file_path,"wb")
            writefile.write(outputText)
            writefile.close()
   
    def _format_output(self,**kwargs):

        results = []

        output = kwargs["output"]
        output_to_json= kwargs.get("output_to_json")

        for _output in output:
            if not _output.strip(): continue
            results.append(_output)

        if not output_to_json: return results

        return json.loads(results)

    def _add_tags(self,resource):

        tags = os.environ.get("RESOURCE_TAGS")
        if not tags: return

        tags = [ tag.strip() for tag in tags.split(",") ]
        if not isinstance(resource.get("tags"),list): resource["tags"] = []
        resource["tags"].extend(tags)
        resource["tags"].append("terraform")

        # remove duplicates
        resource["tags"] = list(set(resource["tags"]))
 
        return resource

    def _get_state_info(self):

        os.chdir(self.terraform_dir)
        cmd = [ "./{}".format(self.postscript) ]
        output = self.execute(cmd,output_to_json=False,exit_error=True).get("output")
        values = convert_ed_output_to_values(output)
        os.chdir(self.run_dir)

        return values

    def get_resource_info(self):

        resource = self._get_state_info()

        if not isinstance(resource,dict): 
            self.logger.warn("resource needs to be a dictionary!")
            exit(9)

        self._add_tags(resource)

        if not resource.get("_id") and isinstance(resource,dict): 
            resource["_id"] = resource["id"]

        # Create destroy resource arguments and reference
        resource["destroy"] = {"shelloutconfig":self.shelloutconfig}
        env_vars = {"METHOD":"destroy"}

        if self.stateful_id: env_vars["STATEFUL_ID"] = self.stateful_id

        if self.inputargs.get("use_docker"):
            resource["method"] = "terraform_docker_env"
            env_vars["USE_DOCKER"] = True
            env_vars["DOCKER_EXEC_ENV"] = self.docker_image
        else:
            resource["working_subdir"] = self.working_subdir
            resource["method"] = "terraform"

        resource["destroy"]["env_vars"] = json.dumps(env_vars)
        resource["destroy"]["insert_env_vars"] = json.dumps(["AWS_ACCESS_KEY_ID", "AWS_SECRET_ACCESS_KEY"])

        return resource

    def _exec_local_create(self):

        cmds = [ "terraform init" ]
        cmds.append("chmod -R 777 .terraform")
        cmds.append("terraform plan")

        os.chdir(self.terraform_dir)
        
        for cmd in cmds: self.execute(cmd,output_to_json=False,exit_error=True)

        cmd = "terraform apply -auto-approve"
        results = self.execute(cmd,output_to_json=False,exit_error=False)

        if results.get("status") is False: 
            cmd = "terraform destroy -auto-approve"
            self.execute(cmd,output_to_json=False,exit_error=False)
            self.logger.error("terraform create failed! tried to revert changes")
            exit(9)

    def _get_env_filepath(self):

        docker_env_file = os.environ.get("DOCKER_ENV_FILE",".env")
        file_path = os.path.join(os.getcwd(),docker_env_file)

        return file_path

    def _create_env_file(self,method):

        docker_env_fields = os.environ.get("DOCKER_ENV_FIELDS")
        file_path = self._get_env_filepath()

        self.logger.debug("Writing environment file {} with field {}".format(file_path,docker_env_fields))

        f = open(file_path,"w")
        f.write("{}={}".format("METHOD",method))

        if not docker_env_fields: 
            f.close()
            return file_path

        for docker_env_field in docker_env_fields.split(","):
            if not os.environ.get(docker_env_field.strip().upper()): continue
            f.write("\n")
            f.write("{}={}".format(docker_env_field.strip().upper(),os.environ[docker_env_field.strip().upper()]))

        f.close()

        return file_path

    def _cleanup_docker_exec_env(self,stateful_path):

        os.chdir(self.terraform_dir)
        cmd = "rm -rf {}".format(stateful_path)
        self.execute(cmd,output_to_json=False,exit_error=False)

    def _exec_docker_run(self,stateful_path,method=None):

        os.chdir(stateful_path)

        if method: 
            docker_env_file = self._create_env_file(method)
        else:
            docker_env_file = self._get_env_filepath()

        if not os.path.exists(docker_env_file):
            self.logger.error("Cannot find environmental file {}".format(docker_env_file))
            exit(9)

        cmd = 'docker run --env-file {} -it --rm -v {}:{} {}'.format(docker_env_file,
                                                                     stateful_path,
                                                                     self.share_dir,
                                                                     self.docker_image)

        return self.execute(cmd,output_to_json=False,exit_error=False)

    def _set_exec_docker_dir(self):

        stateful_path = os.path.join(self.share_dir,self.stateful_id)

        # create working docker run directory
        cmds = []
        if os.path.exists(stateful_path): 
            cmds.append("rm -rf {}".format(stateful_path))
        cmds.append("rsync -avug {}/ {}".format(self.terraform_dir,stateful_path))

        for cmd in cmds:
            self.execute(cmd,output_to_json=False,exit_error=True)

        return stateful_path

    def _exec_docker_create(self):

        stateful_path = self._set_exec_docker_dir()
        results = self._exec_docker_run(stateful_path,method="create")

        if results.get("status") is False: 
            results = self._exec_docker_run(stateful_path,method="destroy")
            self._cleanup_docker_exec_env(stateful_path)
            self.logger.error("terraform create failed! tried to revert changes")
            exit(9)

        cmd = "rsync -avug {}/ {}".format(stateful_path,self.terraform_dir)
        self.execute(cmd,output_to_json=False,exit_error=True)

        # clean up stateful_path that was used for docker execution
        self._cleanup_docker_exec_env(stateful_path)

    def create(self):

        if self.use_docker and not self.stateful_id:
            self.logger.error("STATEFUL_ID needs to be set for using of docker run environments")

        self._templify(**self.inputargs)

        if not os.path.exists(self.terraform_dir):
            self.logger.warn("terraform directory must exists at {} - something went wrong".format(self.terraform_dir))
            os.chdir(self.run_dir)
            exit(9)

        if not os.path.exists(self.postscript_path):
            self.logger.warn("script to parse terraform must exists here {}".format(self.postscript_path))
            exit(9)

        if not self.inputargs.get("use_docker"): 
            self._exec_local_create()
        else:
            self._exec_docker_create()

        os.chdir(self.run_dir)
        resource = self.get_resource_info()
        self.print_output(output=resource)

    def _exec_local_destroy(self):

        if os.path.exists(self.terraform_dir):
            exec_dir = self.terraform_dir
        else:
            exec_dir = self.run_dir

        os.chdir(exec_dir)

        cmds = [ "chmod -R 777 .terraform" ]
        #cmds.append("terraform init")
        cmds.append("terraform destroy -auto-approve")

        for cmd in cmds:
            for retry in range(0,3):
                results = self.execute(cmd,output_to_json=None)
                if results.get("status") is True: return results
                self.logger.debug('having trouble destroying terraform resource at "{}"'.format(exec_dir))
                sleep(1)

        return results

    def _exec_docker_destroy(self):

        stateful_path = self._set_exec_docker_dir()
        results = self._exec_docker_run(stateful_path,method=None)

        # Testingyoyo
        # clean up stateful_path that was used for docker execution
        #self._cleanup_docker_exec_env(stateful_path)
        raise

        return results

    def destroy(self):

        if not self.inputargs.get("use_docker"): 
            results = self._exec_local_destroy()
        else:
            results = self._exec_docker_destroy()

        os.chdir(self.run_dir)
        self.successful_output(output=results.get("output"))

def usage():

    print """
script + environmental variables

or

script + json_input (as argument)

environmental variables:

    basic:
        USE_DOCKER (optional for USE_DOCKER) - use docker run execution
        STATEFUL_ID (needed for USE_DOCKER) - the stateful_id to reference for recording the state
        DOCKER_ENV_FIELDS (optional for USE_DOCKER) - the environmental keys to create environmental file with
        DOCKER_EXEC_ENV (default elasticdev/terraform-run-env) - docker container/image to run execution with
        DOCKER_ENV_FILE (default .env) - name of the docker env file to create
        SHARE_DIR (default is /var/tmp/share) - the directory that is shared with docker host that is 
                                                used for the volume sharing when execution

        METHOD - create/destroy

        WORKING_DIR (optional) - working base directory to execute from
        TERRAFORM_DIR (optional) - if WORKING_DIR not set, check this variable

        CLOBBER (optional - to clobber existing templified if it exists already)

        TERRAFORM_TEMPLATE_FILES (optional) - files to create configuration files for

        POSTSCRIPT (optional) - run after the execution.  typically used to parse the terraform
                                state file

    create:
        RESOURCE_TYPE
        RESOURCE_TAGS
        OS_TEMPLATE_VARS - environmental variables use for templating terraform files

    destroy:

       """
    exit(4)

if __name__ == '__main__':

    try:
        json_input = sys.argv[1]
    except:
        json_input = None

    main = Main()

    if json_input:
        main.set_inputargs(json_input=json_input)
    else:
        set_env_vars = [ "method",
                         "use_docker",
                         "clobber",
                         "working_dir",
                         "terraform_dir",
                         "terraform_template_files",
                         "resource_type",
                         "resource_tags",
                         "os_template_vars" ]

        main.set_inputargs(set_env_vars=set_env_vars)
   
    method = main.inputargs.get("method")

    if not method:
        print "method/ENV VARIABLE METHOD is needed"
        exit(4)

    if method == "create":

        main.check_required_inputargs(keys=["resource_type","os_template_vars"])
        main.create()

    elif method == "destroy":
        main.destroy()

    else:
        usage()
        print 'method "{}" not supported!'.format(method)
        exit(4)

