#!/usr/bin/env python
#
#This file is part of "jiffy".
#
#Project: jiffy: A product for building and managing infrastructure: 
#cloud provider services, and servers and their configurations.
#
#Description: A product for building and managing infrastructure. 
#This includes third party API calls for services such as virtual
#cloud servers, load balancers, databases, and other. The product 
#manages connectivity and appropriate communication among these 
#aws.
#
#Copyright (C) Gary Leong - All Rights Reserved
#Unauthorized copying of this file, via any medium is strictly prohibited
#Proprietary and confidential
#Written by Gary Leong  <gwleong@gmail.com, June 17,2020

import jinja2
import os
import json
import sys
from time import sleep

from ed_helper_publisher.loggerly import ElasticDevLogger
from ed_helper_publisher.resource_manage import ResourceCmdHelper
from ed_helper_publisher.output import convert_ed_output_to_values

class MissingEnvironmentVariable(Exception):
    pass

# dup dhdskyeucnfhrt2634521 
def get_tf_env_var(variable,default=None,must_exists=None):

    _value = os.environ.get(variable)
    if _value: return _value

    _value = os.environ.get("TF_VAR_{}".format(variable))
    if _value: return _value

    _value = os.environ.get("TF_VAR_{}".format(variable.lower()))
    if _value: return _value

    _value = os.environ.get("TF_VAR_{}".format(variable.upper()))
    if _value: return _value

    if default: return default

    if not must_exists: return
    raise MissingEnvironmentVariable("{} does not exist".format(variable))

class Main(ResourceCmdHelper):

    def __init__(self,**kwargs):

        ResourceCmdHelper.__init__(self)
        self.classname = 'TerraformWrapper'
        self.logger = ElasticDevLogger(self.classname,logcategory="cloudprovider")
        self.logger.debug("Instantiating %s" % self.classname)

        # The working directory that terraform files will be copied to
        self.working_subdir = get_tf_env_var("TERRAFORM_DIR")
        if not self.working_subdir: self.working_subdir = os.environ.get("WORKING_SUBDIR","var/tmp/terraform")

        # The postscript file that will be execute after terraform execution is completed.
        # Typically, this file reads the tfstate file, prints to the standard out to be recorded
        # and stored in the ED resource table to be used/referenced by other automation.
        self.postscript = os.environ.get("POSTSCRIPT","tfstate_to_output")

        # This the default script run that will capture the terraform outputted from the 
        # postscript file to be stored to be referenced and used.  For example, we can store
        # the vpc id, vm/instance id, database endpoint
        self.shelloutconfig = "elasticdev:::terraform::resource_wrapper"

        # The docker image to execute terraform files
        self.docker_image = get_tf_env_var("DOCKER_EXEC_ENV",default="elasticdev/terraform-run-env")

        # By default, we USE_DOCKER to execute the terraform files.  If disabled, the 
        # terrform files will be executed directly by the worker which has a specific 
        # versiion of terraform installed.
        self.use_docker = get_tf_env_var("USE_DOCKER")

        # The shared directory is the location in the worker that is temporarily shared with the 
        # Docker execution container.  This is only used if USE_DOCKER is True.
        self.share_dir = get_tf_env_var("SHARE_DIR",default="/var/tmp/share")

        # The state_id is typically automated and provided by the stack calling this script.
        # The state_id will reference this specific terraform automation for modification
        # and destroying
        self.stateful_id = get_tf_env_var("STATEFUL_ID",must_exists=True)

        # stateful_dir
        self.stateful_dir = get_tf_env_var("STATEFUL_DIR")

        # run_share_dir
        if self.stateful_id:
            self.run_share_dir = os.path.join(self.share_dir,self.stateful_id)
        else:
            self.run_share_dir = self.share_dir

        if self.stateful_dir:
            # credentials directory
            self.creds_dir = os.path.join(self.stateful_dir,".creds")
        else:
            self.creds_dir = None

        # The names of the terraform files that are templated and need to be 
        # rendered.  This is typically variables with a "ja2" suffix for
        # jinja2 which is used for templating and rendering
        self.terraform_template_files = get_tf_env_var("TERRAFORM_TEMPLATE_FILES")

        if not self.terraform_template_files:
            self.terraform_template_files = [ "variables" ]
        else:
            self.terraform_template_files = [ template_file.strip() for template_file in self.terraform_template_files.split(",") ]

        try:
            self.destroy_env_vars = eval(os.environ.get("DESTROY_ENV_VARS"))
            #self.destroy_env_vars = eval(get_tf_env_var("DESTROY_ENV_VARS")
        except:
            self.destroy_env_vars = None

        self.destroy_execgroup = get_tf_env_var("DESTROY_EXECGROUP")

        self.run_dir = os.getcwd()
        self.terraform_dir = os.path.join(self.run_dir,self.working_subdir)
        self.postscript_path = os.path.join(self.terraform_dir,self.postscript)

    def _templify(self,**kwargs):

        clobber = kwargs.get("clobber")

        for template_file in self.terraform_template_files:

            template_filepath = os.path.join(self.terraform_dir,"{}.ja2".format(template_file))
            file_path = os.path.join(self.terraform_dir,"{}.tf".format(template_file))

            if os.path.exists(file_path) and not clobber:
                self.logger.warn("terraform variables file already exists at {} - skipping templifying of it".format(file_path))
                return

            if not os.path.exists(template_filepath):
                self.logger.error("terraform variables template does not exists at {} - skipping templifying of it".format(template_filepath))
                os.chdir(self.run_dir)
                exit(9)
                return

            self.logger.debug("creating terraform variables file {} from {}".format(file_path,template_filepath))

            templateVars = {}

            for _var in get_tf_env_var("OS_TEMPLATE_VARS").split(","):
                var = _var.strip().upper()
                if not os.environ.get(var): continue
                # For Terraform, you need to use double quotes instead of second quotes
                templateVars[var] = os.environ[var].replace("'",'"')

            templateLoader = jinja2.FileSystemLoader(searchpath="/")
            templateEnv = jinja2.Environment(loader=templateLoader)
            template = templateEnv.get_template(template_filepath)
            outputText = template.render( templateVars )
            writefile = open(file_path,"wb")
            writefile.write(outputText)
            writefile.close()
   
    def _format_output(self,**kwargs):

        results = []

        output = kwargs["output"]
        output_to_json= kwargs.get("output_to_json")

        for _output in output:
            if not _output.strip(): continue
            results.append(_output)

        if not output_to_json: return results

        return json.loads(results)

    def _add_tags(self,resource):

        tags = get_tf_env_var("RESOURCE_TAGS")
        if not tags: return

        tags = [ tag.strip() for tag in tags.split(",") ]
        if not isinstance(resource.get("tags"),list): resource["tags"] = []
        resource["tags"].extend(tags)
        resource["tags"].append("terraform")

        # remove duplicates
        resource["tags"] = list(set(resource["tags"]))
 
        return resource

    def _get_state_info(self):

        script_path = os.path.join(self.terraform_dir,self.postscript)

        if not os.path.exists(script_path):
            self.logger.warn("post script {} does not exists".format(script_path))
            return 

        os.chdir(self.terraform_dir)
        cmd = [ "./{}".format(self.postscript) ]
        output = self.execute(cmd,output_to_json=False,exit_error=True).get("output")
        values = convert_ed_output_to_values(output)
        os.chdir(self.run_dir)

        return values

    def _get_resource_info(self):

        resource = self._get_state_info()

        if not resource: return 

        if not isinstance(resource,dict) and not isinstance(resource,list):
            self.logger.warn("resource needs to be a dictionary or list!")
            exit(9)

        if isinstance(resource,dict): 
            self._add_tags(resource)
            self._add_destroy_parameters(resource)

        if isinstance(resource,list):
            for _resource in resource:
                self._add_tags(_resource)
                if not _resource.get("main"): continue
                self._add_destroy_parameters(_resource)

        return resource

    def _add_destroy_parameters(self,resource):

        '''
        we typically load the destroy parameters along with created resource like a 
        VPC or database 

        the resource is therefore self contained, whereby it specifies to the 
        system how it can be destroyed.

        for terraform, we include things like the docker image used to 
        destroy the resource and any environmental variables 
        '''

        # Create destroy resource arguments and reference
        resource["destroy"] = {"shelloutconfig":self.shelloutconfig}

        # environmental variables to include during destruction
        env_vars = {"METHOD":"destroy"}
        if self.destroy_env_vars: env_vars = dict(env_vars,**self.destroy_env_vars)

        if self.stateful_id: env_vars["STATEFUL_ID"] = self.stateful_id

        if self.inputargs.get("use_docker"):
            resource["method"] = "terraform_docker_env"
            env_vars["USE_DOCKER"] = True
            env_vars["DOCKER_EXEC_ENV"] = self.docker_image
        else:
            resource["working_subdir"] = self.working_subdir
            resource["method"] = "terraform"

        resource["destroy"]["env_vars"] = json.dumps(env_vars)
        if env_vars.get("STATEFUL_ID"): resource["destroy"]["stateful_id"] = env_vars["STATEFUL_ID"]

        if self.destroy_execgroup: resource["destroy"]["execgroup"] = self.destroy_execgroup

        # by default, we include default AWS credentials to be inserted during the destroy.  
        # we can also modify this script, upload, and version it to include things like GCP and Azure credentials.
        resource["destroy"]["insert_env_vars"] = json.dumps(["AWS_ACCESS_KEY_ID", "AWS_SECRET_ACCESS_KEY"])

        return resource

    def _exec_local_create(self):

        '''
        executes terraform locally on the work rather than a specific 
        docker container
        '''

        cmds = [ "terraform init" ]
        cmds.append("chmod -R 777 .terraform")
        cmds.append("terraform plan")

        os.chdir(self.terraform_dir)
        
        for cmd in cmds: self.execute(cmd,output_to_json=False,exit_error=True)

        cmd = "terraform apply -auto-approve"
        results = self.execute(cmd,output_to_json=False,exit_error=False)

        if results.get("status") is False: 
            cmd = "terraform destroy -auto-approve"
            self.execute(cmd,output_to_json=False,exit_error=False)
            self.logger.error("terraform create failed! tried to revert changes")
            exit(9)

    def _get_env_filepath(self):

        docker_env_file = get_tf_env_var("DOCKER_ENV_FILE",default=".env")
        file_path = os.path.join(os.getcwd(),docker_env_file)

        return file_path

    def _create_env_file(self,method):

        try:
            tf_keys = [ tf_key for tf_key in os.environ.keys() if "TF_VAR" in tf_key ]
        except:
            tf_keys = None

        docker_env_fields = get_tf_env_var("DOCKER_ENV_FIELDS")
        file_path = self._get_env_filepath()

        self.logger.debug("Writing environment file {} with field {}".format(file_path,docker_env_fields))

        f = open(file_path,"w")
        f.write("{}={}".format("METHOD",method))

        if tf_keys:
            for tf_key in tf_keys:
                tf_value = os.environ.get(tf_key)
                if not tf_key: continue
                f.write("\n")
                f.write("{}={}".format(tf_key,tf_value))

        if docker_env_fields: 
            for docker_env_field in docker_env_fields.split(","):
                if not os.environ.get(docker_env_field.strip().upper()): continue
                f.write("\n")
                f.write("{}={}".format(docker_env_field.strip().upper(),os.environ[docker_env_field.strip().upper()]))

        f.close()

        return file_path

    def _cleanup_docker_exec_env(self):

        os.chdir(self.terraform_dir)
        cmd = "rm -rf {}".format(self.run_share_dir)
        self.execute(cmd,output_to_json=False,exit_error=False)

    def _exec_docker_run(self,method=None,create_env=None):

        os.chdir(self.run_share_dir)

        if method and create_env: 
            docker_env_file = self._create_env_file(method)
        else:
            docker_env_file = self._get_env_filepath()

        if not os.path.exists(docker_env_file):
            self.logger.error("Cannot find environmental file {}".format(docker_env_file))
            exit(9)

        if method:
            cmd = 'docker run -e METHOD="{}" --env-file {} --rm -v {}:{} {}'.format(method,
                                                                                    docker_env_file,
                                                                                    self.run_share_dir,
                                                                                    self.share_dir,
                                                                                    self.docker_image)
        else:
            cmd = 'docker run --env-file {} --rm -v {}:{} {}'.format(docker_env_file,
                                                                     self.run_share_dir,
                                                                     self.share_dir,
                                                                     self.docker_image)

        return self.execute(cmd,output_to_json=False,exit_error=False)

    def _set_exec_docker_dir(self):

        # create working docker run directory
        cmds = []

        _dirname = os.path.dirname(self.run_share_dir)
        if not os.path.exists(_dirname):
            cmds.append("mkdir -p {}".format(_dirname))

        self.logger.debug("rsync -avug {}/ {}".format(self.terraform_dir,self.run_share_dir))

        if self.creds_dir and os.path.exists(self.creds_dir):
            cmds.append("rsync -avug {} {}/".format(self.creds_dir,self.terraform_dir))

        cmds.append("rsync -avug {}/ {}".format(self.terraform_dir,self.run_share_dir))

        for cmd in cmds:
            self.execute(cmd,output_to_json=False,exit_error=True)

        return True

    def _exec_docker_create(self):

        self._set_exec_docker_dir()
        results = self._exec_docker_run(method="create",create_env=True)

        if results.get("status") is False: 
            self._exec_docker_run(method="destroy",create_env=True)
            #self._cleanup_docker_exec_env()
            self.logger.error("Terraform create failed here {}! Tried to revert changes".format(self.run_share_dir))
            exit(9)

        cmd = "rsync -avug {}/ {}".format(self.run_share_dir,self.terraform_dir)
        self.execute(cmd,output_to_json=False,exit_error=True)

        # clean up credentials directories
        #cmd = "rm -rf {}/.creds".format(self.terraform_dir)
        #self.execute(cmd,output_to_json=False,exit_error=False)

        # clean up run_share_dir that was used for docker execution
        self._cleanup_docker_exec_env()

        return results

    def _exec_docker_destroy(self):

        self._set_exec_docker_dir()
        results = self._exec_docker_run(method="destroy")

        # clean up run_share_dir that was used for docker execution
        self._cleanup_docker_exec_env()

        return results

    def _exec_local_destroy(self):

        if os.path.exists(self.terraform_dir):
            exec_dir = self.terraform_dir
        else:
            exec_dir = self.run_dir

        os.chdir(exec_dir)

        cmds = [ "chmod -R 777 .terraform" ]
        #cmds.append("terraform init")
        cmds.append("terraform destroy -auto-approve")

        for cmd in cmds:
            for retry in range(0,3):
                results = self.execute(cmd,output_to_json=None)
                if results.get("status") is True: return results
                self.logger.debug('having trouble destroying terraform resource at "{}"'.format(exec_dir))
                sleep(1)

        return results

    def create(self):

        if self.use_docker and not self.stateful_id:
            self.logger.error("STATEFUL_ID needs to be set for using of docker run environments")

        self._templify(**self.inputargs)

        if not os.path.exists(self.terraform_dir):
            self.logger.warn("terraform directory must exists at {} - something went wrong".format(self.terraform_dir))
            os.chdir(self.run_dir)
            exit(9)

        if not os.path.exists(self.postscript_path):
            self.logger.warn("script to parse terraform must exists here {}".format(self.postscript_path))
            exit(9)

        if not self.inputargs.get("use_docker"): 
            self._exec_local_create()
        else:
            results = self._exec_docker_create()

            if results.get("output"):
                self.print_output(output=results["output"])

        os.chdir(self.run_dir)
        resource = self._get_resource_info()
        if not resource: exit(0)

        self.print_output(output=resource)

    def destroy(self):

        if not self.inputargs.get("use_docker"): 
            results = self._exec_local_destroy()
        else:
            results = self._exec_docker_destroy()

        os.chdir(self.run_dir)
        if not results.get("output"): return

        self.successful_output(output=results.get("output"))

def usage():

    print """
script + environmental variables

or

script + json_input (as argument)

environmental variables:

    basic:
        USE_DOCKER (optional for USE_DOCKER) - use docker container for execution
        STATEFUL_ID (needed for USE_DOCKER) - the stateful_id to reference the state of the execution
        DOCKER_ENV_FIELDS (optional for USE_DOCKER) - the environmental keys to create environmental file 
        DOCKER_EXEC_ENV (default elasticdev/terraform-run-env) - the docker container/image to run execution
        DOCKER_ENV_FILE (default .env) - name of the docker env file to create
        SHARE_DIR (default is /var/tmp/share) - the shared directory that is shared with the worker during docker container execution

        METHOD - create/destroy

        TERRAFORM_DIR (optional) - we use the terraform directory relative to execution directory
        WORKING_SUBDIR (optional) - if TERRAFORM_DIR not set, we use the WORKING_SUBDIR to reference terraform build environment
        CLOBBER (optional) - clobbers existing templified files if they already exist)
        TERRAFORM_TEMPLATE_FILES (optional) - template files to create configuration files 

        POSTSCRIPT (optional) - run after the execution.  typically used to parse the terraform state file

    create:
        RESOURCE_TYPE
        RESOURCE_TAGS
        OS_TEMPLATE_VARS - environmental variables use for templating terraform files

    destroy:

       """
    exit(4)

if __name__ == '__main__':

    try:
        json_input = sys.argv[1]
    except:
        json_input = None

    main = Main()

    if json_input:
        main.set_inputargs(json_input=json_input)
    else:
        set_env_vars = [ "method",
                         "use_docker",
                         "clobber",
                         "working_dir",
                         "terraform_dir",
                         "terraform_template_files",
                         "resource_type",
                         "resource_tags",
                         "os_template_vars" ]

        main.set_inputargs(set_env_vars=set_env_vars)
   
    method = main.inputargs.get("method")

    if not method:
        print "method/ENV VARIABLE METHOD is needed"
        exit(4)

    if method == "create":

        main.check_required_inputargs(keys=["os_template_vars"])
        main.create()

    elif method == "destroy":
        main.destroy()

    else:
        usage()
        print 'method "{}" not supported!'.format(method)
        exit(4)

